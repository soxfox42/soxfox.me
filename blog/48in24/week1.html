<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <meta
      name="description"
      content="Week 1 of #48in24, let's look at Leap!"
    />

    <meta property="og:url" content="https://soxfox.me/blog/48in24/week1.html">
    <meta property="og:type" content="website">
    <meta property="og:title" content="#48in24, week 1 - soxfox">
    <meta property="og:description" content="Week 1 of #48in24, let's look at Leap!">
    <meta property="og:image" content="https://soxfox.me/blog/images/og_week1.png">

    <title>#48in24, week 1 - soxfox</title>

    <!-- syntax highlighting -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
      media="screen and (prefers-color-scheme: dark)"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/mipsasm.min.js"></script>

    <link rel="stylesheet" href="/style.css" />
    <link rel="icon" type="image/png" href="/favicon.png" />
  </head>
  <body>
    <header>
      <div>
        <img src="/images/soxfox.webp" alt="" class="logo" />
        <a href="/">soxfox</a>
        <div class="spacer"></div>
        <a href="https://github.com/soxfox42">
          <img src="/images/gh.svg" alt="soxfox42 on GitHub" class="social" />
        </a>
        <a href="https://aus.social/@soxfox42" rel="me">
          <img
            src="/images/masto.svg"
            alt="soxfox42 on Mastodon"
            class="social"
          />
        </a>
      </div>
    </header>

    <div class="banner">
      <div class="title">
        <h1>#48in24 – Week 1</h1>
        <p>Published 19th January 2024</p>
        <p><a href="/blog">← Back to Posts</a></p>
      </div>
    </div>

    <main>
      <h1>Exercise</h1>

      <p>
        The first featured exercise of the year is "Leap". This is a pretty
        simple exercise, which is to be expected at this point in the challenge.
        It consists of a single function of the form
        <code class="hl">fn is_leap_year(year: u64) -> bool</code>. The goal is
        to return a boolean indicating whether the given year is a leap year
        according to the standard Gregorian calendar rules.
      </p>

      <p>Here is a quick explanation of those rules:</p>
      <ul>
        <li>A year is a leap year if it is divisible by 4...</li>
        <li>unless it is divisible by 100...</li>
        <li>unless it is also divisible by 400.</li>
      </ul>

      <h1>Languages</h1>

      <h2>Python</h2>

      <p>
        First up in the featured languages is Python, a well known, simple to
        use language. It is a fairly typical imperative programming language,
        with syntax that uses indentation for blocks, rather than e.g. braces.
        My solution to Leap in Python was the following:
      </p>

      <pre><code>def leap_year(year):
    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)</code></pre>

      <p>
        This is a pretty standard boolean logic approach to checking leap years.
        Thanks to short-circuiting boolean operators, it doesn't perform
        unnecessary checks (though the runtime cost of a few <code>%</code> and
        <code>==</code> operators is next to nothing).
      </p>

      <p>The Python solution is unsurprisingly simple, so let's move on.</p>

      <h2>C (bonus!)</h2>

      <p>
        C wasn't a featured language here, but I had previously completed Leap
        in Clojure, so I needed another language in order to claim my silver and
        gold ranks. My solution is almost identical to the Python one though:
      </p>

      <pre><code>bool leap_year(int year) {
    return year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0);
}</code></pre>

      <p>
        There's nothing new here to address, as this is a straightforward
        translation of the previous solution. I promise the next one will be
        more interesting!
      </p>

      <h2>Clojure</h2>

      <p>
        Time for something completely different: a Lisp. Lisp family languages
        get a bad reputation for being unreadable piles of parentheses))))))). I
        don't think this is entirely fair though - any language can be hard to
        read if you aren't used to it, or if it was written poorly. Generally,
        when reading Lisp code, you tune out the parentheses, and rely more on
        clean indentation to understand the code.
      </p>

      <p>
        As mentioned before, I had already solved this one, but my previous
        solution was just another boolean logic implementation, and I wanted to
        try something a little more interesting. Here's what I came up with:
      </p>

      <pre><code>(defn leap-year? [year]
  (cond
    (not (zero? (mod year 4))) false
    (not (zero? (mod year 100))) true
    (not (zero? (mod year 400))) false
    :else true))</code></pre>

      <p>
        The star of this solution is Clojure's
        <a href="https://clojuredocs.org/clojure.core/cond"
          ><code>cond</code></a
        >
        macro. It's a little like a <code>switch</code> statement but for
        arbitrary conditions, a cleaner way to write
        <code>if-else</code> chains. I haven't seen this in many other
        languages, though Kotlin's <code>when</code> comes to mind.
      </p>

      <p>
        I used negated versions of the divisibility checks here as I wanted to
        keep the same order to them. If we find that a year is not divisible by
        four, we can return false right away, and this applies to each
        divisibility check in turn.
      </p>

      <p>
        Personally, I'm a huge fan of Lisps. Something about the fact that you
        can't really reduce the language syntax much more without making a near
        unusable language really appeals to me. Reducing the language syntax
        happens to be exactly what our final language does though, so let's go!
      </p>

      <h2>MIPS Assembly</h2>

      <p>
        ...yeah. Syntax doesn't get much more minimal than this - labels and
        instructions, that's it. Here's the code:
      </p>

      <pre><code>is_leap_year:
    rem $t0, $a0, 4
    beqz $t0, divisible_by_four

    li $v0, 0
    jr $ra

divisible_by_four:
    rem $t0, $a0, 100
    beqz $t0, divisible_by_hundred

    li $v0, 1
    jr $ra

divisible_by_hundred:
    rem $t0, $a0, 400
    beqz $t0, divisible_by_four_hundred

    li $v0, 0
    jr $ra

divisible_by_four_hundred:
    li $v0, 1
    jr $ra</code></pre>

      <p>
        That's an awful lot of code to check whether a year is a leap year, but
        that's just what programming in assembly gets you. Luckily, it's
        basically the same piece of code three times, so I'll break down one of
        those units.
      </p>

      <pre><code>    rem $t0, $a0, 4
    beqz $t0, divisible_by_four

    li $v0, 0
    jr $ra

divisible_by_four:</code></pre>

      <p>
        This is the unit of code that makes up my assembly solution. First, a
        bit of context. <code>$a0</code> is the CPU register that holds the
        first argument (the year), and <code>$v0</code> is the CPU register used
        to return the result of 0 or 1.
      </p>

      <ol>
        <li>
          <code class="hl language-mipsasm">rem $t0, $a0, 4</code> calculates
          the value of <code>$a0</code> modulo 4, and stores it in
          <code>$t0</code>, a temporary register.
        </li>
        <li>
          <code class="hl language-mipsasm">beqz $t0, divisible_by_four</code>
          checks if that value is zero, and if it is, jumps ahead to
          <code>divisible_by_four</code>.
        </li>
        <li>
          If we didn't jump to the next check,
          <code class="hl language-mipsasm">li $v0, 0</code> and
          <code class="hl language-mipsasm">jr $ra</code> load 0 into the return
          value register, and return to the caller.
        </li>
      </ol>

      <p>
        That was a lot. At this point, all that's left is to run 3 of these
        checks in sequence with the right return values, and add a final return
        value of 1 at the end. The logic here is basically identical to my
        Clojure solution, it just doesn't look like it.
      </p>

      <p>
        I want to address a quirk of MIPS assembly quickly. The MIPS
        architecture has very few instructions compared to many others, but MARS
        (the assembler and simulator used by Exercism) makes coding easier by
        introducing many pseudo-instructions. Some are simple, like
        <code>beqz</code> and <code>li</code> above - they assemble to a regular
        <code>beq</code> and an immediate add respectively. Some are more
        complex, like <code>rem</code>. MIPS can't divide by an immediate value
        natively, so MARS assembles this to an immediate load (which is really
        an add), a <code>div</code> instruction, which calculates division and
        remainder at the same time, and a <code>mfhi</code> to fetch the result
        into a register. A special register - <code>$ra</code> - exists for the
        assembler to use in pseudo-instructions like this.
      </p>

      <p>
        I've had some experience coding in a few assembly languages, but the
        vast majority of my experience comes from
        <a href="https://www.zachtronics.com/">Zachtronics</a> games (go check
        them out!). Applying those skills to real assembly is surprisingly
        simple, but sometimes there are interesting new things to learn about,
        like the pseudo-instructions above. Assembly always feels like a fun
        puzzle to me, so it's nice to see it getting some attention straight
        away in #48in24.
      </p>

      <h1>Final Thoughts</h1>

      <p>
        I'm really looking forward to the next 47 weeks. I see a lot of
        potential for learning new programming tricks, both in languages I know,
        and those I don't! I hope to write one of these blog posts for each
        exercise, but only time will tell whether I can stick to that. Thanks
        for reading this post, I hope you found something new and interesting
        here!
      </p>
    </main>

    <script>
      document.querySelectorAll("pre > code, code.hl").forEach((el) => {
        hljs.highlightElement(el);
      });
    </script>
  </body>
</html>
